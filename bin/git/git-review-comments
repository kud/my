#!/usr/bin/env zsh
# git-review-comments — Browse PR review comments with fzf
#
# Usage:
#   git-review-comments            # infer repo and current PR
#   git-review-comments <number>   # browse specific PR number
#   git review-comments            # as a git external command

set -uo pipefail

err() { printf "%s\n" "$*" >&2; }
need() { command -v "$1" >/dev/null 2>&1 || { err "Missing dependency: $1"; return 1; } }

# Ensure a sane PATH when executed as a git external command (minimal env)
export PATH="$PATH:/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"

# Required deps
for bin in gh jq fzf awk sed base64 wc tr nl cat chmod cut rev; do
  need "$bin" || { err "Please install '$bin' and try again."; exit 1; }
done

# Optional markdown renderer and syntax highlighter
GLOW_BIN=$(command -v glow 2>/dev/null || true)
MDCAT_BIN=$(command -v mdcat 2>/dev/null || true)
BAT_BIN=$(command -v bat 2>/dev/null || true)

# Resolve executables we will call explicitly later
FZF_BIN=$(command -v fzf)
AWK_BIN=$(command -v awk)
SED_BIN=$(command -v sed)
BASE64_BIN=$(command -v base64)
WC_BIN=$(command -v wc)
TR_BIN=$(command -v tr)
NL_BIN=$(command -v nl)
CAT_BIN=$(command -v cat)
CHMOD_BIN=$(command -v chmod)
CUT_BIN=$(command -v cut)
REV_BIN=$(command -v rev)
OPEN_BIN=$(command -v open 2>/dev/null || true)
PBCOPY_BIN=$(command -v pbcopy 2>/dev/null || true)
XCLIP_BIN=$(command -v xclip 2>/dev/null || true)
XSEL_BIN=$(command -v xsel 2>/dev/null || true)

# Utility functions
decode_base64() {
  printf '%s' "$1" | "${BASE64_BIN}" --decode 2>/dev/null || printf '%s' "$1" | "${BASE64_BIN}" -D 2>/dev/null
}

get_field() {
  local file="$1" field="$2"
  "${SED_BIN}" -n "s/^${field}: //p" "$file"
}

copy_to_clipboard() {
  if [ -n "${PBCOPY_BIN:-}" ]; then
    "${PBCOPY_BIN}" 2>/dev/null || return 1
  elif [ -n "${XCLIP_BIN:-}" ]; then
    "${XCLIP_BIN}" -selection clipboard 2>/dev/null || return 1
  elif [ -n "${XSEL_BIN:-}" ]; then
    "${XSEL_BIN}" --clipboard --input 2>/dev/null || return 1
  else
    return 1
  fi
}

# Parse args: optional PR number (positional) and author filter(s)
PR_NUMBER=""
AUTHORS=""

normalize_author() {
  local a="${1:-}"
  case "$a" in
    copilot|@copilot) printf "%s" "copilot-pull-request-reviewer" ;;
    *)                printf "%s" "$a" ;;
  esac
}

while [ $# -gt 0 ]; do
  case "$1" in
    -a|--author)
      [ -n "${2:-}" ] || { err "--author requires a value"; exit 1; }
      norm="$(normalize_author "$2")"
      if [ -z "$AUTHORS" ]; then AUTHORS="$norm"; else AUTHORS="$AUTHORS,$norm"; fi
      shift 2
      ;;
    ''|*[!0-9]*)
      # Unknown/non-numeric arg — ignore to stay simple
      shift
      ;;
    *)
      PR_NUMBER="$1"; shift
      ;;
  esac
done

# Infer owner/repo
OWNER=""; REPO=""
if info="$(gh repo view --json owner,name --jq '.owner.login+" " + .name' 2>/dev/null)"; then
  OWNER="${info%% *}"
  REPO="${info##* }"
else
  remote_url="$(git remote get-url origin 2>/dev/null || git remote get-url upstream 2>/dev/null || true)"
  [ -n "${remote_url:-}" ] || { err "Cannot infer repository; ensure you're inside a GitHub repo or run gh repo set-default."; exit 1; }
  if printf "%s" "$remote_url" | grep -q '^git@github.com:'; then
    path_part="${remote_url#*:}"; path_part="${path_part%.git}"
  elif printf "%s" "$remote_url" | grep -q '^https://github.com/'; then
    path_part="${remote_url#https://github.com/}"; path_part="${path_part%.git}"
  else
    err "Remote is not a GitHub URL: $remote_url"; exit 1
  fi
  OWNER="${path_part%%/*}"; REPO="${path_part#*/}"
fi

# Infer PR number if not provided
if [ -z "$PR_NUMBER" ]; then
  if num="$(gh pr view --json number --jq .number 2>/dev/null)"; then
    [ -n "$num" ] && [ "$num" != "null" ] && PR_NUMBER="$num"
  fi
fi
if [ -z "$PR_NUMBER" ]; then
  branch="$(git branch --show-current 2>/dev/null || true)"
  if [ -n "${branch:-}" ]; then
    num="$(gh pr list --state all --head "$branch" --json number --jq '.[0].number' 2>/dev/null || true)"
    [ -n "$num" ] && [ "$num" != "null" ] && PR_NUMBER="$num"
  fi
fi
[ -n "$PR_NUMBER" ] || { err "Could not determine PR number. Pass it as an argument or run on a PR branch."; exit 1; }

# GraphQL query (review threads + comments)
read -r -d '' QUERY <<'GQL'
query($owner:String!, $name:String!, $number:Int!) {
  repository(owner:$owner, name:$name) {
    pullRequest(number:$number) {
      reviewThreads(first: 100) {
        nodes {
          path
          line
          originalLine
          isResolved
          comments(first: 100) {
            nodes {
              author { login }
              body
              bodyText
              url
              path
              diffHunk
              createdAt
            }
          }
        }
      }
    }
  }
}
GQL

# Fetch JSON
JSON="$(gh api graphql -f query="$QUERY" -f owner="$OWNER" -f name="$REPO" -F number="$PR_NUMBER" 2>/dev/null)" || {
  err "GitHub API failed. Are you authenticated? (gh auth login)"; exit 1;
}

# Validate/clean JSON
printf '%s' "$JSON" | jq . >/dev/null 2>&1 || {
  JSON="$(printf '%s' "$JSON" | perl -pe 's/[\x00-\x1F]//g')"
  printf '%s' "$JSON" | jq . >/dev/null 2>&1 || { err "Invalid JSON from GitHub API"; exit 1; }
}

# Temp workspace
TMPDIR="/tmp/git-review-comments-$$"
mkdir -p "$TMPDIR"
cleanup() { command rm -rf "$TMPDIR" >/dev/null 2>&1 || true; }
trap cleanup EXIT INT TERM

# Extract unresolved comments into TSV:
# author, path, line, url, date, preview, diff_b64, body_b64
TSV="$TMPDIR/comments.tsv"


printf '%s' "$JSON" | jq -r --arg authors "$AUTHORS" '
  ($authors | split(",") | map(select(length>0))) as $A |
  .data.repository.pullRequest.reviewThreads.nodes // [] |
  map(select(.isResolved == false)) |
  map(. as $t | ($t.comments.nodes // []) | map(. + { thread_path: $t.path, thread_line: ($t.line // $t.originalLine), thread_resolved: $t.isResolved })) |
  add // [] |
  (if ($A|length) > 0 then map(select(.author.login as $l | ($A | index($l)))) else . end) |
  .[] |
  [
    (.author.login // "unknown"),
    (.thread_path // .path // "unknown"),
    (.thread_line // null),
    (.url // ""),
    (.createdAt // "" | split("T")[0]),
    ((.body // .bodyText // "") | gsub("[\n\r\t]"; " ") | gsub("  +"; " ") | .[0:80]),
    ((.diffHunk // "") | @base64),
    ((.body // .bodyText // "") | @base64)
  ] | @tsv
' > "$TSV"

if [ ! -s "$TSV" ]; then
  err "No unresolved review comments found for ${OWNER}/${REPO} PR #${PR_NUMBER}."
  exit 0
fi

# Create per-comment files and display list
LIST="$TMPDIR/list"
: > "$LIST"
idx=0
while IFS=$'\t' read -r author path line url date preview diff_b64 body_b64; do
  {
    printf "Author: %s\n" "$author"
    printf "Path: %s\n" "${path}${line:+:$line}"
    printf "Date: %s\n" "$date"
    printf "URL: %s\n" "$url"
    printf "Preview: %s\n" "$preview"
    printf "Diff: %s\n" "$diff_b64"
    printf "Body: %s\n" "$body_b64"
  } > "$TMPDIR/$idx"
  
  # Create display alias for copilot
  display_author="$author"
  case "$author" in
    *copilot*) display_author="copilot" ;;
  esac
  
  # Truncate file path if too long (keep first 30 and last 20 chars for more space)
  full_path="${path}${line:+:$line}"
  if [ ${#full_path} -gt 55 ]; then
    truncated_path="$(echo "$full_path" | "$CUT_BIN" -c1-30)…$(echo "$full_path" | "$REV_BIN" | "$CUT_BIN" -c1-20 | "$REV_BIN")"
  else
    truncated_path="$full_path"
  fi
  
  # Format: Author (8 chars) + space + Path (up to 50 chars) + space + date
  max_path_length=50
  if [ ${#truncated_path} -gt $max_path_length ]; then
    truncated_path="$(echo "$truncated_path" | "$CUT_BIN" -c1-$((max_path_length-1)))…"
  fi
  
  printf '\033[36m%-8s\033[0m \033[33m%-50s\033[0m \033[90m%s\033[0m\n' \
    "$display_author" \
    "$truncated_path" \
    "$date" >> "$LIST"
  idx=$((idx+1))
done < "$TSV"

count="$("$WC_BIN" -l < "$LIST" | "$TR_BIN" -d ' ')"
header="${OWNER}/${REPO} • PR #${PR_NUMBER} • ${count} unresolved comment(s)
Enter/Ctrl-Y: copy • Ctrl-O: open in browser

"

# Create preview script
PREVIEW_SCRIPT="$TMPDIR/preview.sh"
{
  printf '#!/bin/sh\n'
  printf 'n=$(echo "$1" | %s '"'"'{print $1-1; exit}'"'"')\n' "$AWK_BIN"
  printf 'f="$2/$n"\n'
  printf 'if [ ! -f "$f" ]; then echo "Comment not found"; exit 1; fi\n'
  printf 'repo="$3"; pr="$4"\n'
  printf 'author=$(%s -n "s/^Author: //p" "$f")\n' "$SED_BIN"
  printf 'path=$(%s -n "s/^Path: //p" "$f")\n' "$SED_BIN"
  printf 'date=$(%s -n "s/^Date: //p" "$f")\n' "$SED_BIN"
  printf 'url=$(%s -n "s/^URL: //p" "$f")\n' "$SED_BIN"
  printf 'diff_b64=$(%s -n "s/^Diff: //p" "$f")\n' "$SED_BIN"
  printf 'body_b64=$(%s -n "s/^Body: //p" "$f")\n' "$SED_BIN"
  printf 'printf "\\033[1;95mRepo:\\033[0m %%s  \\033[1;95mPR:\\033[0m #%%s\\n" "$repo" "$pr"\n'
  printf 'printf "\\033[1;36mAuthor:\\033[0m @%%s\\n" "$author"\n'
  printf 'printf "\\033[1;33mFile:\\033[0m %%s\\n" "$path"\n'
  printf 'printf "\\033[1;90mDate:\\033[0m %%s\\n" "$date"\n'
  printf 'printf "\\033[1;90mURL:\\033[0m %%s\\n\\n" "$url"\n'
  printf 'if [ -n "$diff_b64" ]; then\n'
  printf '  echo "\\033[1;35mCode Context:\\033[0m"\n'
  printf '  decoded_diff=$(printf "%%s" "$diff_b64" | %s --decode 2>/dev/null || printf "%%s" "$diff_b64" | %s -D 2>/dev/null)\n' "$BASE64_BIN" "$BASE64_BIN"
  printf '  echo "$decoded_diff" | while IFS= read -r line; do\n'
  printf '    case "$line" in\n'
  printf '      -*)  printf "\\033[31m%%s\\033[0m\\n" "$line" ;;\n'
  printf '      +*)  printf "\\033[32m%%s\\033[0m\\n" "$line" ;;\n'
  printf '      @@*) printf "\\033[94m%%s\\033[0m\\n" "$line" ;;\n'
  printf '      *)   printf "\\033[37m%%s\\033[0m\\n" "$line" ;;\n'
  printf '    esac\n'
  printf '  done\n'
  printf '  echo\n'
  printf 'fi\n'
  printf 'echo\n'
  printf 'echo "\\033[1;32mComment:\\033[0m"\n'
  printf 'decoded_body=$(printf "%%s" "$body_b64" | %s --decode 2>/dev/null || printf "%%s" "$body_b64" | %s -D 2>/dev/null)\n' "$BASE64_BIN" "$BASE64_BIN"
  if [ -n "$GLOW_BIN" ]; then
    printf 'printf "%%s" "$decoded_body" | %s --style=dark --width=80 2>/dev/null || printf "%%s" "$decoded_body"\n' "$GLOW_BIN"
  elif [ -n "$MDCAT_BIN" ]; then
    printf 'printf "%%s" "$decoded_body" | %s --no-colour 2>/dev/null || printf "%%s" "$decoded_body"\n' "$MDCAT_BIN"
  else
    # Simple but effective markdown parsing
    printf 'printf "%%s" "$decoded_body" | %s '"'"'\n' "$SED_BIN"
    printf '  # Handle code blocks first\n'
    printf '  :code_start\n'
    printf '  /^```/ {\n'
    printf '    s/.*/\\033[2;37m&\\033[0m/\n'
    printf '    n\n'
    printf '    :code_loop\n'
    printf '    /^```/b code_end\n'
    printf '    s/.*/\\033[48;5;236m\\033[97m&\\033[0m/\n'
    printf '    n\n'
    printf '    b code_loop\n'
    printf '    :code_end\n'
    printf '    s/.*/\\033[2;37m&\\033[0m/\n'
    printf '  }\n'
    printf '  \n'
    printf '  # Headers\n'
    printf '  s/^# \\(.*\\)/\\033[1;4m\\1\\033[0m/g\n'
    printf '  s/^## \\(.*\\)/\\033[1m\\1\\033[0m/g\n'
    printf '  s/^### \\(.*\\)/\\033[1;90m\\1\\033[0m/g\n'
    printf '  \n'
    printf '  # Inline code (not in code blocks)\n'
    printf '  s/`\\([^`]*\\)`/\\033[48;5;236m\\033[97m \\1 \\033[0m/g\n'
    printf '  \n'
    printf '  # Bold and italic\n'
    printf '  s/\\*\\*\\([^*]*\\)\\*\\*/\\033[1m\\1\\033[0m/g\n'
    printf '  s/\\*\\([^*]*\\)\\*/\\033[3m\\1\\033[0m/g\n'
    printf '  \n'
    printf '  # Bullet points\n'
    printf '  s/^- \\(.*\\)/  \\033[36m•\\033[0m \\1/g\n'
    printf '  s/^  - \\(.*\\)/    \\033[36m◦\\033[0m \\1/g\n'
    printf '  \n'
    printf '  # Numbered lists\n'
    printf '  s/^[0-9]*\\. \\(.*\\)/  \\033[33m▸\\033[0m \\1/g\n'
    printf ''"'"'\n'
  fi
} > "$PREVIEW_SCRIPT"

"$CHMOD_BIN" +x "$PREVIEW_SCRIPT"

# Create copy script
COPY_SCRIPT="$TMPDIR/copy.sh"
{
  printf '#!/bin/sh\n'
  printf 'n=$(echo "$1" | %s '"'"'{print $1-1; exit}'"'"')\n' "$AWK_BIN"
  printf 'f="$2/$n"\n'
  printf 'if [ -f "$f" ]; then\n'
  printf '  author=$(%s -n "s/^Author: //p" "$f")\n' "$SED_BIN"
  printf '  path=$(%s -n "s/^Path: //p" "$f")\n' "$SED_BIN"
  printf '  date=$(%s -n "s/^Date: //p" "$f")\n' "$SED_BIN"
  printf '  url=$(%s -n "s/^URL: //p" "$f")\n' "$SED_BIN"
  printf '  body_b64=$(%s -n "s/^Body: //p" "$f")\n' "$SED_BIN"
  printf '  decoded_body=$(printf "%%s" "$body_b64" | %s --decode 2>/dev/null || printf "%%s" "$body_b64" | %s -D 2>/dev/null)\n' "$BASE64_BIN" "$BASE64_BIN"
  printf '  \n'
  printf '  # Format the complete comment with metadata using printf for proper newlines\n'
  printf '  {\n'
  printf '    printf "Review Comment\\n"\n'
  printf '    printf "Author: @%%s\\n" "$author"\n'
  printf '    printf "File: %%s\\n" "$path"\n'
  printf '    printf "Date: %%s\\n" "$date"\n'
  printf '    printf "URL: %%s\\n\\n" "$url"\n'
  printf '    printf "%%s\\n" "$decoded_body"\n'
  printf '  } | ('
  if [ -n "$PBCOPY_BIN" ]; then
    printf '%s' "$PBCOPY_BIN"
  elif [ -n "$XCLIP_BIN" ]; then
    printf '%s -selection clipboard' "$XCLIP_BIN"
  elif [ -n "$XSEL_BIN" ]; then
    printf '%s --clipboard --input' "$XSEL_BIN"
  else
    printf '%s >/dev/null' "$CAT_BIN"
  fi
  printf ' 2>/dev/null)\n'
  printf 'fi\n'
} > "$COPY_SCRIPT"

# Create open script  
OPEN_SCRIPT="$TMPDIR/open.sh"
{
  printf '#!/bin/sh\n'
  printf 'n=$(echo "$1" | %s '"'"'{print $1-1; exit}'"'"')\n' "$AWK_BIN"
  printf 'f="$2/$n"\n'
  printf 'if [ -f "$f" ]; then\n'
  printf '  url=$(%s -n "s/^URL: //p" "$f")\n' "$SED_BIN"
  printf '  if [ -n "$url" ]; then\n'
  if [ -n "$OPEN_BIN" ]; then
    printf '    %s "$url" 2>/dev/null || xdg-open "$url" 2>/dev/null\n' "$OPEN_BIN"
  else
    printf '    xdg-open "$url" 2>/dev/null\n'
  fi
  printf '  fi\n'
  printf 'fi\n'
} > "$OPEN_SCRIPT"

"$CHMOD_BIN" +x "$COPY_SCRIPT" "$OPEN_SCRIPT"

# Run fzf  
"$NL_BIN" -ba -w2 "$LIST" | "$FZF_BIN" --ansi \
  --prompt='comments> ' \
  --header="$header" \
  --height=100% --border=rounded --layout=reverse \
  --preview-window='right:60%:wrap' \
  --preview "$PREVIEW_SCRIPT {} $TMPDIR ${OWNER}/${REPO} ${PR_NUMBER}" \
  --bind "enter:execute-silent($COPY_SCRIPT {} $TMPDIR)+accept" \
  --bind "ctrl-y:execute-silent($COPY_SCRIPT {} $TMPDIR)" \
  --bind "ctrl-o:execute-silent($OPEN_SCRIPT {} $TMPDIR)"

exit 0
