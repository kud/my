#!/usr/bin/env node
// Interactive (editorless) git rebase plan
// Lets you choose actions per-commit: pick, reword, edit, squash, fixup, drop
// Requires: Node >= 24 (repo engines), deps from package.json: inquirer, zx

import fs from "node:fs"
import os from "node:os"
import path from "node:path"
import process from "node:process"
import { $ } from "zx"
import chalk from "chalk"
import inquirer from "inquirer"

// Keep output quiet by default
$.verbose = false

const ACTIONS = [
  { name: "pick    (use commit)", value: "pick" },
  { name: "reword  (edit commit message)", value: "reword" },
  { name: "edit    (edit during rebase)", value: "edit" },
  {
    name: "squash  (meld commit into previous, edit message)",
    value: "squash",
  },
  {
    name: "fixup   (meld commit into previous, discard message)",
    value: "fixup",
  },
  { name: "drop    (remove commit)", value: "drop" },
]

function print(msg) {
  process.stdout.write(msg + "\n")
}

async function ensureGitRepo() {
  try {
    await $`git rev-parse --is-inside-work-tree`
  } catch {
    print("Not a git repository.")
    process.exit(1)
  }
}

async function getDefaultRemoteBranch() {
  // Attempt origin/HEAD
  try {
    const { stdout } =
      await $`git symbolic-ref --quiet --short refs/remotes/origin/HEAD`
    const ref = stdout.trim()
    if (ref) return path.posix.basename(ref)
  } catch {}
  // Fallback via remote show
  try {
    const { stdout } = await $`git remote show origin`
    const m = stdout.match(/HEAD branch: (.+)/)
    if (m) return m[1].trim()
  } catch {}
  // Last resort: main/master
  try {
    await $`git show-ref --verify --quiet refs/remotes/origin/main`
    return "main"
  } catch {}
  try {
    await $`git show-ref --verify --quiet refs/remotes/origin/master`
    return "master"
  } catch {}
  print("Unable to determine origin's default branch.")
  process.exit(1)
}

async function getCurrentBranch() {
  try {
    const { stdout } = await $`git symbolic-ref --quiet --short HEAD`
    return stdout.trim()
  } catch {
    const { stdout } = await $`git rev-parse --abbrev-ref HEAD`
    return stdout.trim()
  }
}

async function fetchOrigin() {
  try {
    await $`git fetch --prune origin`
  } catch (e) {
    print("Failed to fetch from origin.")
    process.exit(1)
  }
}

function parseArgs(argv) {
  const args = {
    base: null,
    from: null,
    quick: false,
    rebaseMerges: true,
    listOnly: false,
  }
  const positionals = []
  for (let i = 2; i < argv.length; i++) {
    const a = argv[i]
    if (a === "--base" || a === "--onto" || a === "-b") {
      args.base = argv[++i]
    } else if (a === "--from" || a === "-f") {
      args.from = argv[++i]
    } else if (a === "--quick" || a === "-q") {
      args.quick = true
    } else if (a === "--no-rebase-merges") {
      args.rebaseMerges = false
    } else if (a === "--list" || a === "-l") {
      args.listOnly = true
    } else if (a === "--help" || a === "-h") {
      print(
        `Usage: git-rebase-plan [<base-ref-or-sha>] [<from-branch-or-ref>] [--base <ref>] [--from <ref>] [--quick] [--list] [--no-rebase-merges]\n\n` +
          `Examples:\n  git-rebase-plan\n  git-rebase-plan origin/main\n  git-rebase-plan origin/main my-feature\n  git-rebase-plan --base origin/main --from my-feature\n  git-rebase-plan 38f8620 my-feature\n  git-rebase-plan --list\n  git-rebase-plan --quick`,
      )
      process.exit(0)
    } else if (a.startsWith("-")) {
      print(`Unknown flag: ${a}`)
      process.exit(1)
    } else {
      positionals.push(a)
    }
  }
  if (!args.base && positionals.length > 0) {
    args.base = positionals[0]
  }
  if (!args.from && positionals.length > 1) {
    args.from = positionals[1]
  }
  return args
}

async function listCommits(rangeRef) {
  // Format: <sha>\x01<subject>
  const { stdout } = await $`git log --reverse --pretty=%H%x01%s ${rangeRef}`
  const lines = stdout.trim() ? stdout.split("\n") : []
  return lines
    .filter((l) => l.trim() !== "")
    .map((l) => {
      const idx = l.indexOf("\u0001")
      let sha = l
      let subject = ""
      if (idx >= 0) {
        sha = l.slice(0, idx)
        subject = l.slice(idx + 1)
      }
      return { sha, subject }
    })
}

async function countCommits(rangeRef) {
  const { stdout } = await $`git rev-list --count ${rangeRef}`
  return parseInt(stdout.trim() || "0", 10)
}

function defaultActionForSubject(subject) {
  if (/^fixup!/i.test(subject)) return "fixup"
  if (/^squash!/i.test(subject)) return "squash"
  return "pick"
}

async function promptActions(commits, quick) {
  const items = commits.map((c) => ({
    ...c,
    action: defaultActionForSubject(c.subject),
  }))
  if (quick || items.length === 0) return items

  print("Select an action for each commit (default shown in brackets).")
  for (let i = 0; i < items.length; i++) {
    const c = items[i]
    const short = c.sha.slice(0, 7)
    const subj = chalk.white(c.subject)
    const answer = await inquirer.prompt([
      {
        type: "list",
        name: "action",
        message: `#${i + 1} ${short} ${subj}`,
        default: c.action,
        choices: ACTIONS,
        pageSize: ACTIONS.length,
      },
    ])
    c.action = answer.action

    // If fixup, ask whether to target previous or a specific commit
    if (c.action === "fixup") {
      const prevSha = i > 0 ? items[i - 1].sha : null
      const { mode } = await inquirer.prompt([
        {
          type: "list",
          name: "mode",
          message: "Fixup target:",
          default: prevSha ? "previous" : "specific",
          choices: [
            {
              name: "previous commit",
              value: "previous",
              disabled: prevSha ? false : "no previous commit",
            },
            { name: "specific commit (choose)", value: "specific" },
          ],
        },
      ])
      if (mode === "specific") {
        const choices = items
          .filter((x) => x.sha !== c.sha)
          .map((x, idx) => ({
            name: `#${idx + 1} ${x.sha.slice(0, 7)} ${x.subject}`,
            value: x.sha,
          }))
        const { target } = await inquirer.prompt([
          {
            type: "list",
            name: "target",
            message: "Select the commit to fix into:",
            choices,
            pageSize: Math.min(choices.length, 20),
            default: prevSha || undefined,
          },
        ])
        c.fixupTargetSha = target
      } else {
        c.fixupTargetSha = prevSha || null
      }
    }
  }
  // Reorder: place any fixup commit immediately after its target
  const order = items.map((x) => x.sha)
  for (const it of items) {
    if (
      it.action === "fixup" &&
      it.fixupTargetSha &&
      it.fixupTargetSha !== it.sha
    ) {
      const fromIdx = order.indexOf(it.sha)
      const targetIdx = order.indexOf(it.fixupTargetSha)
      if (fromIdx !== -1 && targetIdx !== -1) {
        order.splice(fromIdx, 1)
        const insertAt = Math.min(targetIdx + 1, order.length)
        order.splice(insertAt, 0, it.sha)
      }
    }
  }
  const bySha = new Map(items.map((x) => [x.sha, x]))
  const reordered = order.map((sha) => bySha.get(sha)).filter(Boolean)
  return reordered
}

function buildTodo(items) {
  // Map actions to todo lines; drop means omit line
  const lines = []
  for (const it of items) {
    if (it.action === "drop") continue
    // Git expects the line: <action> <sha> <subject>
    lines.push(`${it.action} ${it.sha} ${it.subject}`)
  }
  // Add helpful comments
  lines.push("# Rebase todo generated by git-rebase-plan")
  return lines.join("\n") + "\n"
}

async function runRebase(baseRef, todoContent, rebaseMerges, branchRef) {
  const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), "git-rebase-plan-"))
  const todoPath = path.join(tmpDir, "todo.txt")
  fs.writeFileSync(todoPath, todoContent, "utf8")

  // Use a wrapper script so the filename passed by git becomes $1 reliably
  const editorPath = path.join(tmpDir, "editor.sh")
  const editorScript = `#!/usr/bin/env sh\ncat "${todoPath}" > "$1"\n`
  fs.writeFileSync(editorPath, editorScript, "utf8")
  fs.chmodSync(editorPath, 0o755)

  const env = { ...process.env, GIT_SEQUENCE_EDITOR: editorPath }

  const args = ["rebase", "-i", "--autosquash", "--autostash", "--empty=drop"]
  if (rebaseMerges) args.push("--rebase-merges")
  args.push(baseRef)
  if (branchRef) args.push(branchRef)
  try {
    await $({ env })`git ${args}`
  } catch (e) {
    print("\nRebase stopped due to conflicts or edits.")
    print("Resolve issues, then run one of:")
    print("  git rebase --continue")
    print("  git rebase --skip")
    print("  git rebase --abort")
    process.exit(e.exitCode ?? 1)
  }
}

async function main() {
  await ensureGitRepo()
  const args = parseArgs(process.argv)

  // Determine base
  await fetchOrigin()
  const def = await getDefaultRemoteBranch()
  const current = await getCurrentBranch()
  const base = args.base || `origin/${def}`
  const targetRef = args.from || "HEAD"

  // Validate target ref if provided
  if (args.from) {
    try {
      await $`git rev-parse --verify --quiet ${targetRef}`
    } catch {
      print(`Unknown --from ref: '${targetRef}'`)
      process.exit(1)
    }
  }

  // Warn if on default branch
  const warnBranch = args.from ? args.from : current
  if (warnBranch === def) {
    print(
      `Warning: you are on the default branch '${def}'. Rebasing here will rewrite its local history.`,
    )
  }

  // Find commits to operate on
  const range = `${base}..${targetRef}`
  const commits = await listCommits(range)
  if (commits.length === 0) {
    const name = args.from || current
    print(`Nothing to rebase: '${name}' has no commits on top of '${base}'.`)
    return
  }

  // Show a summary and list first
  const baseAhead = await countCommits(`${targetRef}..${base}`)
  print(chalk.bold(`Base: ${base}`))
  print(chalk.bold(`Branch: ${args.from || current}`))
  print(`Your branch is ahead by ${commits.length} commit(s).`)
  if (baseAhead > 0) print(`Base is ahead by ${baseAhead} commit(s).`)
  print("")
  print("Commits to rebase (oldest first):")
  for (const c of commits) {
    print(`  • ${chalk.gray(c.sha.slice(0, 7))} ${chalk.white(c.subject)}`)
  }
  print("")

  if (args.listOnly) return

  print(
    `Preparing rebase of ${commits.length} commit(s) from '${
      args.from || current
    }' onto '${base}'.`,
  )
  const items = await promptActions(commits, args.quick)
  const todo = buildTodo(items)

  print("\nStarting rebase...")
  await runRebase(base, todo, args.rebaseMerges, args.from || null)
  print("\nRebase complete.")
}

main().catch((e) => {
  print(String(e?.message || e))
  process.exit(1)
})
