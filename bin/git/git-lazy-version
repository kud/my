#!/usr/bin/env zsh

# Lazy version bump + push helper
# Improves on original by:
# - validating input (patch|minor|major)
# - failing fast (set -euo pipefail)
# - collapsing two pushes into one (git push --follow-tags)
# - showing resulting version
# - guarding against missing package.json

set -euo pipefail

usage() {
  echo "Usage: git lazy-version {major|minor|patch}" >&2
  echo "Aliases: x=major, y=minor, z=patch" >&2
}

arg=${1:-}
case "$arg" in
  major|x)
    VERSION_TYPE=major ;;
  minor|y)
    VERSION_TYPE=minor ;;
  patch|z)
    VERSION_TYPE=patch ;;
  -h|--help|"")
    usage; exit 1 ;;
  *)
    echo "Error: version type must be one of: major minor patch (aliases: x y z)" >&2
    usage; exit 1 ;;
esac

if [[ ! -f package.json ]]; then
  echo "Error: package.json not found (run inside the project root)." >&2
  exit 1
fi

# Stage & AI commit current changes so that `npm version` finds a clean tree.
git add -A
if ! git aicommit; then
  echo "Error: git aicommit failed" >&2
  exit 1
fi

# Capture old version (best effort)
OLD_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "?")

# Perform bump (suppress noisy npm output) and read new version
npm version "$VERSION_TYPE" >/dev/null
NEW_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "?")

# Single push including tag
git push --follow-tags

# Fancy summary (TTY & colors if possible)
if [[ -t 1 && -z ${NO_COLOR:-} ]]; then
  B=$'\e[1m'; R=$'\e[0m'; G=$'\e[32m'; Y=$'\e[33m'; C=$'\e[36m'; M=$'\e[35m'; GRY=$'\e[90m'
else
  B=""; R=""; G=""; Y=""; C=""; M=""; GRY=""
fi

# Default simple one‑liner (less brittle for fonts)
if [[ -z ${GIT_LAZY_VERSION_BOX:-} ]]; then
  echo "${G}v${OLD_VERSION}${R} ➜ ${G}v${NEW_VERSION}${R} (${C}${VERSION_TYPE}${R}) tag: v${NEW_VERSION}" | sed 's/v\?\?/?/'
  exit 0
fi

# Optional boxed output when GIT_LAZY_VERSION_BOX=1
strip_ansi() { printf '%s' "$1" | sed -E $'s/\x1b\[[0-9;]*m//g'; }
LINES=( "Version bump: v${OLD_VERSION} -> v${NEW_VERSION}" "Type: ${VERSION_TYPE}" "Tag: v${NEW_VERSION}" )
LONGEST=0
for raw in "${LINES[@]}"; do
  vis=$(strip_ansi "$raw")
  (( ${#vis} > LONGEST )) && LONGEST=${#vis}
done
EDGE=$(printf '%*s' $(( LONGEST + 4 )) '' | tr ' ' '─')
print_line() {
  local raw="$1"; local vis=$(strip_ansi "$raw")
  local pad=$(( LONGEST - ${#vis} ))
  (( pad < 0 )) && pad=0
  printf "│ %s%*s │\n" "$raw" $pad ""
}

echo
printf "${B}┌%s┐${R}\n" "$EDGE"
print_line "${B}${LINES[1]}${R}"  # first line (Version bump...)
print_line "${C}${LINES[2]}${R}"  # Type
print_line "${LINES[3]}"          # Tag
printf "${B}└%s┘${R}\n" "$EDGE"
echo
