#! /usr/bin/env zsh

set -euo pipefail

# gh-repo-rename - GitHub CLI extension to rename the current repository
# Usage:
#   gh repo-rename <new-name> [--rename-directory] [-n] [-f] [--remote origin]
# This script is installed as an executable named gh-repo-rename so that the
# GitHub CLI picks it up as an extension command: `gh repo-rename`.

SCRIPT_NAME=${0##*/}

usage() {
  cat <<EOF
Usage: gh repo-rename [options] <new-repo-name>

Rename the current GitHub repository (remote) using the GitHub CLI and update the local remote URL.

Options:
  -r, --remote <name>     Remote to use (default: origin)
      --rename-directory  Also rename the local directory if its name matches the old repo name
  -n, --dry-run           Show what would happen without making changes
  -f, --force             Skip confirmation prompt
  -h, --help              Show this help

Examples:
  gh repo-rename new-name
  gh repo-rename --rename-directory new-name
  gh repo-rename -n new-name

Notes:
  1. Requires authenticated gh CLI in this repository.
  2. Only the repository name changes; the owner stays the same.
  3. Local branches/history unaffected; remote URL updated.
EOF
}

err() { printf "Error: %s\n" "$1" >&2; exit "${2:-1}"; }
info() { printf "%s\n" "$*"; }
warn() { printf "Warning: %s\n" "$*" >&2; }
run() { if $dry_run; then printf "[dry-run] %s\n" "$*"; else eval "$*"; fi }

confirm() {
  local prompt="$1"; shift || true
  if $force; then return 0; fi
  printf "%s [y/N]: " "$prompt" >&2
  local reply
  read -r reply || true
  [[ "$reply" == "y" || "$reply" == "Y" ]] || return 1
  return 0
}

remote=origin
dry_run=false
rename_dir=false
force=false

args=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    -r|--remote) remote=${2:-}; [[ -z "$remote" ]] && err "--remote requires a value" 64; shift 2 ;;
    --rename-directory) rename_dir=true; shift ;;
    -n|--dry-run) dry_run=true; shift ;;
    -f|--force) force=true; shift ;;
    -h|--help) usage; exit 0 ;;
    --) shift; break ;;
    -*) err "Unknown option: $1" 64 ;;
    *) args+="$1"; shift ;;
  esac
done

if [[ ${#args[@]} -ne 1 ]]; then
  usage >&2
  exit 64
fi

new_name=${args[1]}
[[ -z "$new_name" ]] && err "New repository name cannot be empty" 64

git rev-parse --is-inside-work-tree &>/dev/null || err "Not inside a git repository" 2
git remote get-url "$remote" &>/dev/null || err "Remote '$remote' not found" 3

remote_url=$(git remote get-url "$remote" | head -n1)

owner_full=""; proto="https"; is_ssh=false
case "$remote_url" in
  git@github.com:*)
    is_ssh=true
    owner_full=${remote_url#git@github.com:}
    owner_full=${owner_full%.git}
    ;;
  https://github.com/*)
    owner_full=${remote_url#https://github.com/}
    owner_full=${owner_full%.git}
    proto="https"
    ;;
  ssh://git@github.com/*)
    is_ssh=true
    owner_full=${remote_url#ssh://git@github.com/}
    owner_full=${owner_full%.git}
    ;;
  *) err "Unsupported remote URL format: $remote_url" 4 ;;
esac

[[ "$owner_full" == */* ]] || err "Failed to parse owner/repo from remote URL" 5
old_name=${owner_full##*/}
owner=${owner_full%/*}

[[ "$old_name" == "$new_name" ]] && err "New name is identical to current repo name ($old_name)" 6
[[ "$new_name" =~ ^[A-Za-z0-9._-]+$ ]] || err "Invalid repo name '$new_name' (allowed: A-Za-z0-9._-)" 7

info "Owner                : $owner"
info "Current repo         : $old_name"
info "New repo name        : $new_name"
info "Remote               : $remote"
info "Remote URL           : $remote_url"
info "Rename directory     : $rename_dir"
info "Mode                 : $([[ $dry_run == true ]] && echo dry-run || echo live)"
echo

command -v gh >/dev/null 2>&1 || err "gh CLI is required" 20

if ! confirm "Proceed with rename?"; then
  err "Aborted by user" 10
fi

if $dry_run; then
  info "[dry-run] gh repo rename $new_name --yes"
else
  gh repo rename "$new_name" --yes || err "gh repo rename failed" 30
fi

new_remote_url=""
if $is_ssh; then
  new_remote_url="git@github.com:${owner}/${new_name}.git"
else
  new_remote_url="https://github.com/${owner}/${new_name}.git"
fi

info "Updating local remote URL -> $new_remote_url"
run "git remote set-url $remote $new_remote_url"

if $rename_dir; then
  current_dir_name=${PWD##*/}
  if [[ "$current_dir_name" == "$old_name" ]]; then
    info "Renaming directory '$current_dir_name' -> '$new_name'"
    if $dry_run; then
      info "[dry-run] mv '../$current_dir_name' '../$new_name'"
    else
      parent_dir=${PWD%/*}
      cd "$parent_dir"
      mv "$current_dir_name" "$new_name"
      cd "$new_name"
    fi
  else
    warn "Directory name ($current_dir_name) != old repo name ($old_name); skipping directory rename"
  fi
fi

info "Done. Repository renamed to '$owner/$new_name'."
if $dry_run; then info "(dry-run) No changes were actually made."; fi

exit 0
