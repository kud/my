#!/bin/zsh
# git-review-pull-request — Browse PR review discussions with fzf
#
# Usage:
#   git-review-pull-request        # infer repo and current PR
#   git-review-pull-request <number> # browse specific PR number
#   git review-pull-request        # as a git external command

set -uo pipefail

err() { printf "%s\n" "$*" >&2; }
need() { command -v "$1" >/dev/null 2>&1 || { err "Missing dependency: $1"; return 1; } }

# Ensure a sane PATH when executed as a git external command (minimal env)
export PATH="$PATH:/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"

# Required deps
for bin in gh jq fzf awk sed base64 wc tr nl cat chmod cut rev; do
  need "$bin" || { err "Please install '$bin' and try again."; exit 1; }
done

# Optional markdown renderer and syntax highlighter
GLOW_BIN=$(command -v glow 2>/dev/null || true)
MDCAT_BIN=$(command -v mdcat 2>/dev/null || true)
BAT_BIN=$(command -v bat 2>/dev/null || true)

# Resolve executables we will call explicitly later
FZF_BIN=$(command -v fzf)
AWK_BIN=$(command -v awk)
SED_BIN=$(command -v sed)
BASE64_BIN=$(command -v base64)
WC_BIN=$(command -v wc)
TR_BIN=$(command -v tr)
NL_BIN=$(command -v nl)
CAT_BIN=$(command -v cat)
CHMOD_BIN=$(command -v chmod)
CUT_BIN=$(command -v cut)
REV_BIN=$(command -v rev)
OPEN_BIN=$(command -v open 2>/dev/null || true)
PBCOPY_BIN=$(command -v pbcopy 2>/dev/null || true)
XCLIP_BIN=$(command -v xclip 2>/dev/null || true)
XSEL_BIN=$(command -v xsel 2>/dev/null || true)

# Utility functions
decode_base64() {
  printf '%s' "$1" | "${BASE64_BIN}" --decode 2>/dev/null || printf '%s' "$1" | "${BASE64_BIN}" -D 2>/dev/null
}

get_field() {
  local file="$1" field="$2"
  "${SED_BIN}" -n "s/^${field}: //p" "$file"
}

copy_to_clipboard() {
  if [ -n "${PBCOPY_BIN:-}" ]; then
    "${PBCOPY_BIN}" 2>/dev/null || return 1
  elif [ -n "${XCLIP_BIN:-}" ]; then
    "${XCLIP_BIN}" -selection clipboard 2>/dev/null || return 1
  elif [ -n "${XSEL_BIN:-}" ]; then
    "${XSEL_BIN}" --clipboard --input 2>/dev/null || return 1
  else
    return 1
  fi
}

# Internal subcommands (invoked by fzf)
sub_preview() {
  # Args: <fzf_line> <tmpdir> <owner/repo> <pr_number>
  local fzf_line="$1" tmpdir="$2" repo="$3" pr="$4"
  local n f
  n=$(printf "%s" "$fzf_line" | "${AWK_BIN}" '{print $1-1; exit}')
  f="$tmpdir/$n"
  if [ ! -f "$f" ]; then echo "Comment not found"; return 1; fi

  # One-shot toast message if present
  if [ -f "$tmpdir/toast" ]; then
    printf "\033[1;32m%s\033[0m\n\n" "$("$CAT_BIN" "$tmpdir/toast" 2>/dev/null)"
    command rm -f "$tmpdir/toast" >/dev/null 2>&1 || true
  fi

  local author path date url diff_b64 body_b64 decoded_diff decoded_body
  author=$(get_field "$f" Author)
  path=$(get_field "$f" Path)
  date=$(get_field "$f" Date)
  url=$(get_field "$f" URL)
  diff_b64=$(get_field "$f" Diff)
  body_b64=$(get_field "$f" Body)

  printf "\033[1;95mRepo:\033[0m %s  \033[1;95mPR:\033[0m #%s\n" "$repo" "$pr"
  printf "\033[1;36mAuthor:\033[0m @%s\n" "$author"
  printf "\033[1;33mFile:\033[0m %s\n" "$path"
  printf "\033[1;90mDate:\033[0m %s\n" "$date"
  printf "\033[1;90mURL:\033[0m %s\n\n" "$url"

  if [ -n "$diff_b64" ]; then
    echo "\033[1;35mCode Context:\033[0m"
    echo
    decoded_diff=$(decode_base64 "$diff_b64")
    echo "$decoded_diff" | while IFS= read -r line; do
      case "$line" in
        -*)  printf "\033[31m%s\033[0m\n" "$line" ;;
        +*)  printf "\033[32m%s\033[0m\n" "$line" ;;
        @@*) printf "\033[94m%s\033[0m\n" "$line" ;;
        *)   printf "\033[37m%s\033[0m\n" "$line" ;;
      esac
    done
    echo
  fi

  echo
  echo "\033[1;32mComment:\033[0m"
  decoded_body=$(decode_base64 "$body_b64")
  if [ -n "$GLOW_BIN" ]; then
    printf "%s" "$decoded_body" | "$GLOW_BIN" --style=dark --width=80 2>/dev/null || printf "%s" "$decoded_body"
  elif [ -n "$MDCAT_BIN" ]; then
    printf "%s" "$decoded_body" | "$MDCAT_BIN" --no-colour 2>/dev/null || printf "%s" "$decoded_body"
  else
    # Minimal markdown styling via sed
    printf "%s" "$decoded_body" | "$SED_BIN" '
      # Handle code blocks first
      :code_start
      /^```/ {
        s/.*/\033[2;37m&\033[0m/
        n
        :code_loop
        /^```/b code_end
        s/.*/\033[48;5;236m\033[97m&\033[0m/
        n
        b code_loop
        :code_end
        s/.*/\033[2;37m&\033[0m/
      }

      # Headers
      s/^# \(.*\)/\033[1;4m\1\033[0m/g
      s/^## \(.*\)/\033[1m\1\033[0m/g
      s/^### \(.*\)/\033[1;90m\1\033[0m/g

      # Inline code (not in code blocks)
      s/`\([^`]*\)`/\033[48;5;236m\033[97m \1 \033[0m/g

      # Bold and italic
      s/\*\*\([^*]*\)\*\*/\033[1m\1\033[0m/g
      s/\*\([^*]*\)\*/\033[3m\1\033[0m/g

      # Bullet points
      s/^- \(.*\)/  \033[36m•\033[0m \1/g
      s/^  - \(.*\)/    \033[36m◦\033[0m \1/g

      # Numbered lists
      s/^[0-9]*\. \(.*\)/  \033[33m▸\033[0m \1/g
    '
  fi
}

sub_copy() {
  # Args: <fzf_line> <tmpdir> [msgfile]
  local fzf_line="$1" tmpdir="$2" msgfile="${3-}"
  local n f
  n=$(printf "%s" "$fzf_line" | "${AWK_BIN}" '{print $1-1; exit}')
  f="$tmpdir/$n"
  [ -f "$f" ] || return 0

  local author path date url body_b64 decoded_body
  author=$(get_field "$f" Author)
  path=$(get_field "$f" Path)
  date=$(get_field "$f" Date)
  url=$(get_field "$f" URL)
  body_b64=$(get_field "$f" Body)
  decoded_body=$(decode_base64 "$body_b64")

  {
    printf "Review Comment\n"
    printf "Author: @%s\n" "$author"
    printf "File: %s\n" "$path"
    printf "Date: %s\n" "$date"
    printf "URL: %s\n\n" "$url"
    printf "%s\n" "$decoded_body"
  } | copy_to_clipboard || true

  # Optional friendly message to be printed by the parent after fzf exits
  if [ -n "$msgfile" ]; then
    {
      printf "Copied the discussion:\n"
      printf "%s\n" "$url"
    } > "$msgfile" 2>/dev/null || true
  fi

  # Prepare in-interface toast for preview (once)
  if printf "%s" "$url" | grep -q '#'; then
    local anchor="${url##*#}"
    anchor="${anchor#discussion_r}"
    printf "✔ Copied discussion %s" "$anchor" > "$tmpdir/toast" 2>/dev/null || true
  else
    printf "✔ Copied discussion" > "$tmpdir/toast" 2>/dev/null || true
  fi
}

sub_open() {
  # Args: <fzf_line> <tmpdir>
  local fzf_line="$1" tmpdir="$2"
  local n f url
  n=$(printf "%s" "$fzf_line" | "${AWK_BIN}" '{print $1-1; exit}')
  f="$tmpdir/$n"
  [ -f "$f" ] || return 0
  url=$(get_field "$f" URL)
  [ -n "$url" ] || return 0
  if [ -n "$OPEN_BIN" ]; then
    "$OPEN_BIN" "$url" 2>/dev/null || command -v xdg-open >/dev/null 2>&1 && xdg-open "$url" 2>/dev/null || true
  else
    command -v xdg-open >/dev/null 2>&1 && xdg-open "$url" 2>/dev/null || true
  fi
}

# If invoked in internal mode, dispatch and exit early
case "${1-}" in
  __preview)
    shift; sub_preview "$@"; exit $? ;;
  __copy)
    shift; sub_copy "$@"; exit $? ;;
  __open)
    shift; sub_open "$@"; exit $? ;;
esac

# Parse args: optional PR number (positional) and author filter(s)
PR_NUMBER=""
AUTHORS=""
# Display mode: latest non-outdated comment per unresolved thread by default
SHOW_MODE="latest"       # values: latest|all
INCLUDE_OUTDATED=0        # 0: exclude outdated comments, 1: include

normalize_author() {
  local a="${1:-}"
  case "$a" in
    copilot|@copilot) printf "%s" "copilot-pull-request-reviewer" ;;
    *)                printf "%s" "$a" ;;
  esac
}

while [ $# -gt 0 ]; do
  case "$1" in
    -a|--author)
      [ -n "${2:-}" ] || { err "--author requires a value"; exit 1; }
      norm="$(normalize_author "$2")"
      if [ -z "$AUTHORS" ]; then AUTHORS="$norm"; else AUTHORS="$AUTHORS,$norm"; fi
      shift 2
      ;;
    --all|--all-comments)
      SHOW_MODE="all"; shift ;;
    --include-outdated)
      INCLUDE_OUTDATED=1; shift ;;
    ''|*[!0-9]*)
      # Unknown/non-numeric arg — ignore to stay simple
      shift
      ;;
    *)
      PR_NUMBER="$1"; shift
      ;;
  esac
done

# Infer owner/repo
OWNER=""; REPO=""
if info="$(gh repo view --json owner,name --jq '.owner.login+" " + .name' 2>/dev/null)"; then
  OWNER="${info%% *}"
  REPO="${info##* }"
else
  remote_url="$(git remote get-url origin 2>/dev/null || git remote get-url upstream 2>/dev/null || true)"
  [ -n "${remote_url:-}" ] || { err "Cannot infer repository; ensure you're inside a GitHub repo or run gh repo set-default."; exit 1; }
  if printf "%s" "$remote_url" | grep -q '^git@github.com:'; then
    path_part="${remote_url#*:}"; path_part="${path_part%.git}"
  elif printf "%s" "$remote_url" | grep -q '^https://github.com/'; then
    path_part="${remote_url#https://github.com/}"; path_part="${path_part%.git}"
  else
    err "Remote is not a GitHub URL: $remote_url"; exit 1
  fi
  OWNER="${path_part%%/*}"; REPO="${path_part#*/}"
fi

# Infer PR number if not provided
if [ -z "$PR_NUMBER" ]; then
  if num="$(gh pr view --json number --jq .number 2>/dev/null)"; then
    [ -n "$num" ] && [ "$num" != "null" ] && PR_NUMBER="$num"
  fi
fi
if [ -z "$PR_NUMBER" ]; then
  branch="$(git branch --show-current 2>/dev/null || true)"
  if [ -n "${branch:-}" ]; then
    num="$(gh pr list --state all --head "$branch" --json number --jq '.[0].number' 2>/dev/null || true)"
    [ -n "$num" ] && [ "$num" != "null" ] && PR_NUMBER="$num"
  fi
fi
[ -n "$PR_NUMBER" ] || { err "Could not determine PR number. Pass it as an argument or run on a PR branch."; exit 1; }

# GraphQL query (review threads + comments)
read -r -d '' QUERY <<'GQL'
query($owner:String!, $name:String!, $number:Int!) {
  repository(owner:$owner, name:$name) {
    pullRequest(number:$number) {
      reviewThreads(first: 100) {
        nodes {
          path
          line
          originalLine
          isResolved
          comments(first: 100) {
            nodes {
              author { login }
              body
              bodyText
              url
              path
              diffHunk
              createdAt
            }
          }
        }
      }
    }
  }
}
GQL

# Fetch JSON
JSON="$(gh api graphql -f query="$QUERY" -f owner="$OWNER" -f name="$REPO" -F number="$PR_NUMBER" 2>/dev/null)" || {
  err "GitHub API failed. Are you authenticated? (gh auth login)"; exit 1;
}

# Validate/clean JSON
printf '%s' "$JSON" | jq . >/dev/null 2>&1 || {
  JSON="$(printf '%s' "$JSON" | perl -pe 's/[\x00-\x1F]//g')"
  printf '%s' "$JSON" | jq . >/dev/null 2>&1 || { err "Invalid JSON from GitHub API"; exit 1; }
}

# Temp workspace
TMPDIR="/tmp/git-review-pull-request-$$"
mkdir -p "$TMPDIR"
cleanup() { command rm -rf "$TMPDIR" >/dev/null 2>&1 || true; }
trap cleanup EXIT INT TERM

# Extract unresolved comments into TSV:
# author, path, line, url, date, preview, diff_b64, body_b64
TSV="$TMPDIR/comments.tsv"

printf '%s' "$JSON" | jq -r \
  --arg authors "$AUTHORS" \
  --arg show_mode "$SHOW_MODE" \
  --argjson include_outdated "$INCLUDE_OUTDATED" '
  ($authors | split(",") | map(select(length>0))) as $A |
  .data.repository.pullRequest.reviewThreads.nodes // [] |
  map(select(.isResolved == false)) |
  map(
    . as $t |
    (
      ($t.comments.nodes // [])
      | (if ($A|length) > 0 then map(select(.author.login as $l | ($A | index($l)))) else . end)
      | (if $include_outdated == 1 then . else map(select((.isOutdated // false) | not)) end)
      | (if $show_mode == "latest" then (sort_by(.createdAt) | (last // empty) | (if . then [.] else [] end)) else . end)
      | map(. + { thread_path: $t.path, thread_line: ($t.line // $t.originalLine), thread_resolved: $t.isResolved })
    )
  ) |
  add // [] |
  .[] |
  [
    (.author.login // "unknown"),
    (.thread_path // .path // "unknown"),
    (.thread_line // null),
    (.url // ""),
    (.createdAt // "" | split("T")[0]),
    ((.body // .bodyText // "") | gsub("[\n\r\t]"; " ") | gsub("  +"; " ") | .[0:80]),
    ((.diffHunk // "") | @base64),
    ((.body // .bodyText // "") | @base64)
  ] | @tsv
' > "$TSV"

if [ ! -s "$TSV" ]; then
  err "No unresolved review comments found for ${OWNER}/${REPO} PR #${PR_NUMBER}."
  exit 0
fi

# Create per-comment files and display list
LIST="$TMPDIR/list"
: > "$LIST"
idx=0
while IFS=$'\t' read -r author path line url date preview diff_b64 body_b64; do
  {
    printf "Author: %s\n" "$author"
    printf "Path: %s\n" "${path}${line:+:$line}"
    printf "Date: %s\n" "$date"
    printf "URL: %s\n" "$url"
    printf "Preview: %s\n" "$preview"
    printf "Diff: %s\n" "$diff_b64"
    printf "Body: %s\n" "$body_b64"
  } > "$TMPDIR/$idx"

  # Create display alias for copilot
  display_author="$author"
  case "$author" in
    *copilot*) display_author="copilot" ;;
  esac

  # Truncate file path if too long (keep first 30 and last 20 chars for more space)
  full_path="${path}${line:+:$line}"
  if [ ${#full_path} -gt 55 ]; then
    truncated_path="$(echo "$full_path" | "$CUT_BIN" -c1-30)…$(echo "$full_path" | "$REV_BIN" | "$CUT_BIN" -c1-20 | "$REV_BIN")"
  else
    truncated_path="$full_path"
  fi

  # Format: Author (8 chars) + space + Path (up to 50 chars) + space + date
  max_path_length=50
  if [ ${#truncated_path} -gt $max_path_length ]; then
    truncated_path="$(echo "$truncated_path" | "$CUT_BIN" -c1-$((max_path_length-1)))…"
  fi

  printf '\033[36m%-8s\033[0m \033[33m%-50s\033[0m \033[90m%s\033[0m\n' \
    "$display_author" \
    "$truncated_path" \
    "$date" >> "$LIST"
  idx=$((idx+1))
done < "$TSV"

count="$("$WC_BIN" -l < "$LIST" | "$TR_BIN" -d ' ')"
header="${OWNER}/${REPO} • PR #${PR_NUMBER} • ${count} unresolved comment(s)
Enter/Ctrl-Y: copy • Ctrl-O: open in browser

"

# Run fzf
SCRIPT_PATH="$0"
case "$SCRIPT_PATH" in
  /*) ;;
  *) SCRIPT_PATH="$(command -v -- "$0" 2>/dev/null || printf '%s' "$0")" ;;
esac

MSG_FILE="$TMPDIR/copied-msg"

"$NL_BIN" -ba -w2 "$LIST" | "$FZF_BIN" --ansi \
  --prompt='comments> ' \
  --header="$header" \
  --height=100% --border=rounded --layout=reverse \
  --preview-window='right:60%:wrap' \
  --preview "'$SCRIPT_PATH' __preview {} $TMPDIR ${OWNER}/${REPO} ${PR_NUMBER}" \
  --bind "enter:execute-silent('$SCRIPT_PATH' __copy {} $TMPDIR $MSG_FILE)+refresh-preview" \
  --bind "ctrl-y:execute-silent('$SCRIPT_PATH' __copy {} $TMPDIR)+refresh-preview" \
  --bind "ctrl-o:execute-silent('$SCRIPT_PATH' __open {} $TMPDIR)"


exit 0
