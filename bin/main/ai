#!/usr/bin/env zsh
################################################################################
#                                                                              #
#   ðŸ¤– AI CLI UTILITIES                                                        #
#   ------------------                                                         #
#   Centralized AI helpers using the `opencode` CLI. Provides higher-level    #
#   convenience functions for common developer tasks.                          #
#                                                                              #
################################################################################

# Default model (overridable via $AI_MODEL or falls back to opencode config)
: ${AI_MODEL:="github-copilot/gpt-4.1"}

# Internal: choose first available markdown renderer, else fallback
ai_markdown_renderer() {
  if command -v glow >/dev/null 2>&1; then
    echo glow
  elif command -v mdcat >/dev/null 2>&1; then
    echo mdcat
  else
    echo ai_markdown_fallback
  fi
}

# Internal: simple markdown-ish pretty printer (headings, lists, code blocks)
ai_markdown_fallback() {
  local line in_code=0
  while IFS= read -r line; do
    if [[ $line == '```'* ]]; then
      if (( in_code )); then
        echo
        in_code=0
      else
        echo
        in_code=1
      fi
      continue
    fi
    if (( in_code )); then
      printf '  %s\n' "$line"
      continue
    fi
    if [[ $line =~ ^#{1,6}\  ]]; then
      local stripped=${line#* }
      printf '\n\033[1m%s\033[0m\n' "$stripped"
      printf '%*s\n' ${#stripped} '' | tr ' ' '='
      continue
    fi
    if [[ $line =~ ^[*-]\  ]]; then
      printf ' â€¢ %s\n' "${line:2}"
      continue
    fi
    if [[ $line =~ ^[0-9]+\.\  ]]; then
      local num=${line%%.*}
      local rest=${line#*. }
      printf '\033[1m%s.\033[0m %s\n' "$num" "$rest"
      continue
    fi
    echo "$line"
  done
}

# Internal helper to call opencode with model fallback and capture clean output
ai_call() {
  if ! command -v opencode >/dev/null 2>&1; then
    echo "Error: opencode CLI not found in PATH." >&2
    return 127
  fi
  local model=${AI_MODEL}
  local prompt=$1
  local raw
  if ! raw=$(opencode run --model "$model" "$prompt" 2>&1); then
    echo "$raw" >&2
    return 1
  fi
  # strip ANSI
  raw=$(print -r -- "$raw" | sed -E 's/\x1b\[[0-9;]*m//g')
  # normalise blank lines
  raw=$(echo "$raw" | sed -E '/^[[:space:]]*$/ {/./!d;:a;N;$!ba;}')
  raw=$(echo "$raw" | sed -E 's/^\[0m[[:space:]]*//')
  printf '%s' "$raw"
}

# explain: explain a shell command with risk, alternatives, example
ai_explain() {
  local plain=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --plain|-p) plain=1; shift ;;
      --model) shift; AI_MODEL=$1; shift ;;
      --) shift; break ;;
      --*) echo "Unknown flag: $1" >&2; return 2 ;;
      *) break ;;
    esac
  done
  if [[ $# -eq 0 ]]; then
    echo "Usage: ai explain [--plain] [--model <model>] <command...>" >&2
    return 1
  fi
  local input_command="$*"
  local prompt="Explain this shell command step by step, then provide: 1) concise plain English summary 2) potential risks 3) safer or common alternatives 4) a practical variant. Command:\n\n$input_command"
  local out
  if ! out=$(ai_call "$prompt"); then
    return 1
  fi
  if (( plain )); then
    echo "$out"; return 0
  fi
  local renderer=$(ai_markdown_renderer)
  echo "$out" | $renderer
}

# tldr: quick what/why/how summary of a command or topic
ai_tldr() {
  if [[ $# -eq 0 ]]; then
    echo "Usage: ai tldr <topic>" >&2
    return 1
  fi
  local prompt="Provide a terse TL;DR (max ~12 lines) for: $*\nFormat with: Heading, What, Why, Typical usage examples (2), Pitfalls."
  local out
  if ! out=$(ai_call "$prompt"); then
    return 1
  fi
  local renderer=$(ai_markdown_renderer)
  echo "$out" | $renderer
}

# summarize: summarise stdin (pipe) or args
ai_summarize() {
  local input
  if [[ -t 0 ]]; then
    if [[ $# -eq 0 ]]; then
      echo "Usage: ai summarize <text...> or pipe data" >&2
      return 1
    fi
    input="$*"
  else
    input=$(cat)
  fi
  local prompt="Summarize the following content into: 1) High-level summary 2) Key points 3) Risks / caveats 4) Action items (if any). Content:\n\n$input"
  local out
  if ! out=$(ai_call "$prompt"); then
    return 1
  fi
  local renderer=$(ai_markdown_renderer)
  echo "$out" | $renderer
}

# debug: suggest next debugging steps for a failing command's stderr
ai_debug() {
  if [[ $# -eq 0 ]]; then
    echo "Usage: ai debug <command...>" >&2; return 1
  fi
  local cmd="$*"
  local output
  if ! output=$(eval "$cmd" 2>&1 >/dev/null); then
    :
  fi
  local prompt="Given this failing command: $cmd\nStderr / diagnostic output:\n\n$output\n\nSuggest structured next debugging steps: 1) Likely root causes 2) Commands to run to verify 3) Potential quick fixes (explicit)."
  local out
  if ! out=$(ai_call "$prompt"); then
    return 1
  fi
  local renderer=$(ai_markdown_renderer)
  echo "$out" | $renderer
}

# cmd: translate natural language into raw zsh commands (no commentary)
ai_cmd() {
  local model_override="" strict=1 multiline=0 shell="zsh"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --model) shift; model_override=$1; shift ;;
      --bash) shell="bash"; shift ;;
      --zsh) shell="zsh"; shift ;;
      --no-strict) strict=0; shift ;;
      --multi|--multiline) multiline=1; shift ;;
      --) shift; break ;;
      --help|-h)
        cat >&2 <<EOF
Usage: ai cmd [options] <natural language request>

Translate a natural language description into one or more ${shell} commands.
Output is RAW commands only (no code fences, no explanation).

Options:
  --model <name>     Use a different model just for this invocation
  --bash|--zsh       Force target shell (default: zsh)
  --multiline        Allow multiple commands separated by newlines
  --no-strict        Allow model to include minimal comments (default strictly commands)
  -h, --help         Show this help

Examples:
  ai cmd list node processes
  ai cmd --multiline clone my repo kud/my and cd into it
  ai cmd --bash compile a c file main.c with warnings enabled
EOF
        return 0
        ;;
      --*) echo "Unknown flag: $1" >&2; return 2 ;;
      *) break ;;
    esac
  done
  if [[ $# -eq 0 ]]; then
    echo "Usage: ai cmd <natural language request>" >&2; return 1
  fi
  [[ -n $model_override ]] && AI_MODEL=$model_override
  local request="$*"
  local constraints="" extra=""
  if (( strict )); then
    constraints+="Rules: 1) Output ONLY valid ${shell} command line(s). 2) NO explanations, NO comments, NO blank prelude. 3) Do not wrap in backticks or fences. "
  else
    constraints+="Rule: Primary output must be executable ${shell} command(s). Keep any comments inline if essential. "
  fi
  if (( ! multiline )); then
    constraints+="Return a SINGLE line command unless truly impossible. Concatenate with '&&' if multiple steps needed. "
  fi
  local prompt="You are going to translate a natural language description into ${shell} shell command(s) for a macOS (Darwin) environment. ${constraints}Description: ${request}\nCommands:"
  local out
  if ! out=$(ai_call "$prompt"); then
    return 1
  fi
  # Sanitize fences/backticks
  out=$(printf '%s' "$out" | sed -E 's/^```[a-zA-Z0-9]*//; s/^```$//; s/^`(.*)`$/\1/; s/^```//; s/```$//')
  # Normalize whitespace, trim empties
  out=$(printf '%s' "$out" | awk 'NF{p=1} p')
  # De-duplicate identical lines while preserving order
  local dedup
  dedup=$(printf '%s\n' "$out" | awk '!seen[$0]++')
  out=$dedup
  # If multiline not requested but we still have multiple lines, collapse with &&
  if (( ! multiline )); then
    local line_count
    line_count=$(printf '%s\n' "$out" | wc -l | tr -d ' ')
    if (( line_count > 1 )); then
      out=$(printf '%s' "$out" | paste -sd ' && ' -)
    fi
  fi
  # Interactive fancy prompt (skip if not TTY or AI_CMD_NO_PROMPT set)
  if [[ -t 1 && -t 0 && -z ${AI_CMD_NO_PROMPT:-} ]]; then
    local B=$'\e[1m' R=$'\e[0m' CY=$'\e[36m' G=$'\e[32m' Y=$'\e[33m' M=$'\e[35m' GRY=$'\e[90m'
    echo
    echo "${B}Proposed Command:${R}"
    while IFS= read -r line; do
      [[ -z $line ]] && continue
      printf "  ${CY}%s${R}\n" "$line"
    done <<< "$out"
    echo
    local choice
    while true; do
      printf "${M}Action?${R} [${G}r${R}un/${Y}e${R}dit/${GRY}c${R}ancel]: "
      read -r choice
      case "$choice" in
        r|R|"") break ;;
        e|E)
          local tmp=$(mktemp /tmp/ai-cmd-XXXX)
            printf '%s\n' "$out" > "$tmp"
            ${EDITOR:-vi} "$tmp"
            out=$(<"$tmp")
            rm -f "$tmp"
            echo
            echo "${B}Updated command(s):${R}"
            printf '%s\n' "$out"
            ;;
        c|C)
          echo "Cancelled."
          return 130
          ;;
        *) echo "Please enter r, e or c." ;;
      esac
    done
    echo
    echo "${G}â†’ Executing...${R}"
    eval "$out"
    return $?
  else
    printf '%s\n' "$out"
  fi
}

# help: list AI helpers
ai_help() {
  local no_color=0
  if [[ -n $NO_COLOR || ! -t 1 ]]; then
    no_color=1
  fi
  if (( no_color )); then
    B="" R="" DIM="" CY="" MAG="" Y="" G="" BL="" GRY=""
  else
    B=$'\e[1m'; R=$'\e[0m'; DIM=$'\e[2m'; CY=$'\e[36m'; MAG=$'\e[35m'; Y=$'\e[33m'; G=$'\e[32m'; BL=$'\e[34m'; GRY=$'\e[90m'
  fi
  local model_disp=${AI_MODEL:-"(unset)"}
  local renderer=$(ai_markdown_renderer)
  [[ $renderer == ai_markdown_fallback ]] && renderer="internal"
  cat <<EOF
${B}ðŸ¤– AI Toolkit${R}  ${DIM}(model: ${model_disp}, render: ${renderer})${R}
${GRY}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${R}

${B}Usage:${R}
  ${CY}ai${R} ${MAG}<command>${R} [options]

${B}Core Commands:${R}
  ${CY}explain${R}    <cmd>          Explain a shell command with risks & alternatives
  ${CY}tldr${R}       <topic>        Ultra-short what / why / examples / pitfalls
  ${CY}summarize${R}  [text]|(pipe)  Summarize provided or piped content
  ${CY}debug${R}      <command>      Suggest structured debugging steps
  ${CY}cmd${R}        <text>         Natural language -> raw shell command(s)

${B}Model Management:${R}
  ${CY}model${R}                     Show current model
  ${CY}model set${R}  <model>        Change and export AI_MODEL for this session

${B}Help:${R}
  ${CY}help${R}                      Show this help

${B}Environment:${R}
  ${Y}AI_MODEL${R}     Current default model (now: ${model_disp})

${B}Examples:${R}
  ${G}ai explain${R} 'grep -R "TODO" -n src'
  ${G}ai summarize${R} < README.md
  ${G}ai model set github-copilot/gpt-4.1${R}
  ${G}ai debug${R} 'curl https://localhost:8443/health'
  ${G}ai cmd${R} 'list largest 5 log files recursively'

${DIM}Tip:${R} Set a persistent model in your shell profile: ${BL}export AI_MODEL=github-copilot/gpt-5${R}
EOF
}

# Main dispatcher: unified entrypoint
main() {
  if [[ $# -eq 0 ]]; then
    ai_help
    return 0
  fi
  local sub=$1; shift || true
  case "$sub" in
    help|-h|--help) ai_help ;;
    explain) ai_explain "$@" ;;
    tldr) ai_tldr "$@" ;;
    summarize|sum) ai_summarize "$@" ;;
    debug) ai_debug "$@" ;;
    cmd|command|translate) ai_cmd "$@" ;;
    model)
      if [[ $# -eq 0 ]]; then
        echo "Current AI_MODEL=$AI_MODEL"
      else
        if [[ $1 == set ]]; then
          shift
          if [[ -z $1 ]]; then
            echo "Usage: ai model set <model>" >&2; return 1
          fi
          AI_MODEL=$1; export AI_MODEL
          echo "AI_MODEL set to $AI_MODEL"
        else
          AI_MODEL=$1; export AI_MODEL
          echo "AI_MODEL set to $AI_MODEL"
        fi
      fi
      ;;
    *)
      echo "Unknown ai subcommand: $sub" >&2
      ai_help >&2
      return 1
      ;;
  esac
}

# Execute main function with all arguments
main "$@"
